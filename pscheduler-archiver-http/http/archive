#!/usr/bin/env python3
"""
Send a result to http.
"""

import io
import sys
import pscheduler
import pscheduler.psurl
import urllib
import pycurl
import http.client
from urllib.parse import urlparse

MAX_SCHEMA = 2

connections = {} # key: scheme hostname port (if port provided)

def archive(json):
    """Archive a single result."""

    schema = json["data"].get("schema", 1)
    if schema > MAX_SCHEMA:
        return {
            "succeeded": False,
            "error": "Unsupported schema version %d; max is %d" % (
                schema, MAX_SCHEMA)
        }

    errors = ()

    try:
        url = json['data']['_url']
    except KeyError:
        raise RuntimeError("Reached code that wasn't supposed to be reached.")

    try:
        op = json['data']['op']
    except KeyError:
        op = 'post'

    try:
        bind = json['data']['bind']
    except KeyError:
        bind = None


    # Headers get special behavior because the Content-Type may be
    # provided explicitly, in which case it's obeyed.  Otherwise,
    # strings will be made text/plain and anything else will be
    # application/json.

    result = pscheduler.json_dump(json['result'])

    try:
        headers = json['data']['_headers']
    except KeyError:
        headers = {}

    # check for content-type header -> if not application/json
    if 'Content-Type' not in headers:
        headers['Content-Type'] = 'application/json'

    if len(headers):
        # Remove all null headers
        headers = dict((k, v) for k, v in headers.items() if v)
        # Stringify all values
        headers = dict((k, str(v)) for k, v in headers.items())

    curl = None

    parsed = urlparse(url)
    scheme = parsed.scheme
    hostname = parsed.hostname
    port = parsed.port

    key = scheme + " " + hostname

    if port is not None:
        key += " "
        key += port

    if key not in connections:
        # Create PycURL object
        curl = pycurl.Curl()
        curl.setopt(pycurl.URL, str(url))

        if bind is not None:
            curl.setopt(pycurl.INTERFACE, str(bind))

        if headers is not None:            
            curl.setopt(pycurl.HTTPHEADER, [
                "%s: %s" % (str(key), str(value))
                for (key, value) in list(headers.items())
            ])

        buf = io.BytesIO()
        curl.setopt(pycurl.WRITEFUNCTION, buf.write)

        connections[key] = curl

    else:
        curl = connections[key]
        buf = io.BytesIO()
        curl.setopt(pycurl.WRITEFUNCTION, buf.write)

    if op == 'post':

        try:
            curl.setopt(pycurl.POSTFIELDS, result)
            try:
                curl.perform()
                status = curl.getinfo(pycurl.HTTP_CODE)
                # PycURL returns a zero for non-HTTP URLs
                if status == 0:
                    status = 200
                text = buf.getvalue().decode()

            except pycurl.error as ex:
                code, message = ex.args
                status = 400
                text = message

            if status < 200 or status > 299:
                raise URLException(text)

        except Exception as ex:
            result = {
                "succeeded": False,
                "error": "Failed to log result: %s" % str(ex)
            }
            if "retry-policy" in json['data']:
                policy = pscheduler.RetryPolicy(json['data']['retry-policy'], iso8601=True)
                retry_time = policy.retry(json["attempts"])
                if retry_time is not None:
                    result["retry"] = retry_time
            return result

    elif op == 'put':

        try:
            curl.setopt(pycurl.CUSTOMREQUEST, "PUT")
            curl.setopt(pycurl.POSTFIELDS, result)
            try:
                curl.perform()
                status = curl.getinfo(pycurl.HTTP_CODE)
                # PycURL returns a zero for non-HTTP URLs
                if status == 0:
                    status = 200
                text = buf.getvalue().decode()

            except pycurl.error as ex:
                code, message = ex.args
                status = 400
                text = message

            if status < 200 or status > 299:
                raise URLException(text)

        except Exception as ex:
            result = {
                "succeeded": False,
                "error": "Failed to log result: %s" % str(ex)
            }
            if "retry-policy" in json['data']:
                policy = pscheduler.RetryPolicy(json['data']['retry-policy'], iso8601=True)
                retry_time = policy.retry(json["attempts"])
                if retry_time is not None:
                    result["retry"] = retry_time
            return result

    else:
        return {
            "succeeded": False,
            "error": "Invalid op arg: %s" % op
        }

    return {'succeeded': True}




PARSER = pscheduler.RFC7464Parser(sys.stdin)
EMITTER = pscheduler.RFC7464Emitter(sys.stdout)

for parsed in PARSER:
    EMITTER(archive(parsed))

pscheduler.succeed()

