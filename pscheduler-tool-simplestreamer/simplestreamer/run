#!/usr/bin/env python3
#
# Run a test.
#

import datetime
import json
import pscheduler
import random
import socket
import sys
import time
import traceback

log = pscheduler.Log(prefix="simplestreamer", quiet=True)

input = pscheduler.json_load(exit_on_error=True);

log.debug("Input is %s", input)

#
# Validate the input
#

if not 'participant-data' in input:
    pscheduler.fail("No participant data.")





# Perform the test

# Ideally, the timeout would be for the whole operation (establishing
# a connection and sending/receiving the data), but that
# implementation is more complex than necessary for this example.
# This makes a very rough approximation 

start_time = datetime.datetime.now()
try:
    timeout = pscheduler.iso8601_as_timedelta(input['test']['spec']['timeout'])
except KeyError:
    timeout = pscheduler.iso8601_as_timedelta('PT5S')
end_time = datetime.datetime.now() + timeout

def time_left():
    return pscheduler.timedelta_as_seconds(end_time - datetime.datetime.now())


random.seed()

# Force a hard failure if one is indicated
try:
    fail_prob = float(input['test']['spec']['fail'])
    fail_rand = random.random()
    if fail_rand < fail_prob:
        results = {
            'succeeded': False,
            'diags': ("Random %f on prob. %f" % (fail_rand, fail_prob)),
            'error': 'Randomly-induced failure',
            'result': None
            }
        pscheduler.succeed_json(results)
except KeyError:
    pass  # Skip it if not in the input


# Both participants need this.

try:
    ip_version = input['test']['spec']['ip-version']
except KeyError:
    (ip_version, err) = pscheduler.ip_addr_version(
        input['test']['spec']['dest'])
    if ip_version is None:
        pscheduler.succeed_json({
            'succeeded': False,
            'error': err
        })

socket_family = socket.AF_INET if ip_version == 4 else socket.AF_INET6


participant = input['participant']


try:
    start_at = input['schedule']['start']
    log.debug("Sleeping until %s", start_at)
    pscheduler.sleep_until(start_at)
    log.debug("Starting")
except KeyError:
    pscheduler.fail("Unable to find start time in input")


if participant == 0:

    #
    # Sender
    #

    # Dawdle if directed.

    try:
        dawdle = pscheduler.timedelta_as_seconds(
            pscheduler.iso8601_as_timedelta(input['test']['spec']['dawdle']) )
        dawdle *= random.random()
        log.debug("Dawdling %s", dawdle)
        time.sleep(dawdle)
    except KeyError:
        dawdle = 0

    # Connect and send the material

    succeeded = False
    error = None

    try:
        material = input['test']['spec']['test-material']
    except KeyError:
        material = "Data sent at " + str(datetime.datetime.now())

    max_tries = 10
    sleep_time = pscheduler.timedelta_as_seconds(timeout) / max_tries
    try_num = 1

    succeeded = False
    diags = []

    while try_num <= max_tries:

        try:
            sock = socket.socket(socket_family, socket.SOCK_STREAM)
            try:
                source = input['test']['spec']['source']
                log.debug("Binding to %s", source)
                sock.bind((source, 0))
            except KeyError:
                pass

            server_address = (input['test']['spec']['dest'],
                              input['participant-data'][1]['listen-port'])
            log.debug("Connecting to %s", str(server_address))
            log.debug("Timeout is %s", str(time_left()))
            time_remaining = time_left()
            if time_remaining <= 0:
                log.debug("Timed out")
                diags.append("Ran out of time trying to connect.")
                break
            sock.settimeout(time_remaining)
            sock.connect(server_address)
            log.debug("Connected")
            sock.sendall(material.encode())
            log.debug("Sent")
            succeeded = True
            error = None
            diags.append("Try %d succeeded." % (try_num))
            break
        except Exception as ex:
            error = ex.args[1] if isinstance(ex, socket.gaierror) else str(ex)
            error = "Failed to connect: %s" % (error)
            diags.append("Try %d failed: %s" % (try_num, error))
            log.debug(error)
            log.debug("Sleeping %s", sleep_time)
            time.sleep(sleep_time)

        try_num += 1

    results = {
        'succeeded': succeeded,
        'diags': "\n".join(diags),
        'error': error,
        'result': {
            'dawdled': pscheduler.timedelta_as_iso8601(
                pscheduler.seconds_as_timedelta(dawdle)),
            'sent': material
            } if succeeded else None
        }

elif participant == 1:

    #
    # Dest
    #

    diags = []
    succeeded = False
    full = ''
    error = None

    try:
        sock = socket.socket(socket_family, socket.SOCK_STREAM)
        sock.settimeout(time_left())
        server_address = (input['test']['spec']['dest'],
                          input['participant-data'][1]['listen-port'])
        diags.append("Listening on %s:%s" % server_address)
        diags.append("Protocol is IPv%d" % (ip_version))
        sock.bind(server_address)
        sock.listen(1)
        connection, client_address = sock.accept()
        connection.settimeout(time_left())

        while True:
            data = connection.recv(1024)
            if data:
                full += data.decode("ascii")
            else:
                break

        connection.close()
        succeeded = True

    except socket.timeout:
        error = "Client never connected."

    except socket.gaierror as ex:
        (err_no, err_str) = ex.args
        error = "Unable to set up listener: %s" % (err_str)

    except Exception as ex:
        error = "Receiver exception: " + str(ex) \
            + " " + traceback.format_exc()

    results = {
        'succeeded': succeeded,
        'diags': "\n".join(diags),
        'error': error if not succeeded else None,
        'result': {
            'received': full,
            'elapsed-time':  pscheduler.timedelta_as_iso8601(
                datetime.datetime.now() - start_time)
            } if succeeded else None
        }

else:

    pscheduler.fail("Invalid participant.")


pscheduler.succeed_json(results)
