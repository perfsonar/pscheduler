#!/usr/bin/python
#
# Convert comamnd-line options to a test specification

import optparse
import pscheduler
import sys
import socket
import pscheduler
import datetime

logger = pscheduler.Log(prefix='test-throughput')

if len(sys.argv) > 1:

   # Args are on the command line
   args = sys.argv[1:]

else:

   # Args are in a JSON array on stdin
   json_args = pscheduler.json_load(exit_on_error=True)
   args = []

   if type(json_args) != list:
      pscheduler.fail("Invalid JSON for this operation")
   for arg in json_args:
      if type(arg) not in (unicode, str, int, float):
         pscheduler.fail("Invalid JSON for this operation")
   args = [ str(arg) for arg in json_args ]



# Gargle the arguments

opt_parser = optparse.OptionParser()

opt_parser.add_option("-s", "--source",
                      help="Sending host",
                      action="store", type="string",
                      dest="source")


opt_parser.add_option("-d", "--dest", "--destination",
                      help="Receiving host",
                      action="store", type="string",
                      dest="destination")

opt_parser.add_option("-t", "--duration",
                      help="Total runtime of test",
                      action="store", type="string",
                      dest="duration")

opt_parser.add_option("-i", "--interval",
                      help="How often to report results (internally, results still reported in aggregate at end)",
                      action="store", type="string",
                      dest="interval")

opt_parser.add_option("-P", "--parallel",
                      help="How many parallel streams to run during the test",
                      action="store", type="int",
                      dest="parallel")

opt_parser.add_option("-u", "--udp",
                      help="Use UDP instead of TCP testing",
                      action="store_true", 
                      dest="udp")

opt_parser.add_option("-b", "--bandwidth",
                      help="Bandwidth to rate limit the test to, supports SI notation such as 1G",
                      action="store", type="string",
                      dest="bandwidth")

opt_parser.add_option("-w", "--window-size",
                      help="TCP window size to use for the test, supports SI notation such as 64M",
                      action="store", type="string",
                      dest="window_size")

opt_parser.add_option("-W", "--dynamic-window-size",
                      help="Dynamic TCP window fallback size, supports SI notation such as 64M",
                      action="store", type="string",
                      dest="dynamic_window_size")

opt_parser.add_option("-m", "--mss",
                      help="TCP maximum segment size",
                      action="store", type="int",
                      dest="mss")

opt_parser.add_option("-l", "--buffer-length",
                      help="length of the buffer to read/write from",
                      action="store", type="int",
                      dest="buffer_length")

opt_parser.add_option("-4", "--force-ipv4",
                      help="Force the test to use IPv4 for source/destination",
                      action="store_true",
                      dest="force_ipv4")

opt_parser.add_option("-6", "--force-ipv6",
                      help="Force the test to use IPv6 for source/destination",
                      action="store_true", 
                      dest="force_ipv6")

opt_parser.add_option("-B", "--local-address",
                      help="Use this as a local address for control and tests",
                      action="store", type="string",
                      dest="local_address")

opt_parser.add_option("--dscp",
                      help="DSCP value for ToS byte",
                      action="store", type="int",
                      dest="dscp")

opt_parser.add_option("-O", "--omit",
                      help="Number of seconds to omit from the start of the test",
                      action="store", type="int",
                      dest="omit")

opt_parser.add_option("--tos",
                      help="Type of service for outgoing packets",
                      action="store", type="int",
                      dest="tos")



(options, remaining_args) = opt_parser.parse_args(args)
if len(remaining_args) != 0:
   pscheduler.fail("Found superfluous arguments on command line.")


result = { 'schema': 1 }

if options.source is not None:
   result['source'] = options.source
   
if options.destination is not None:
   result['destination'] = options.destination

if options.duration is not None:
   duration = options.duration

   # convert epoch seconds to is8601
   if duration.isdigit():
      delta = datetime.timedelta(seconds=int(duration))
      duration = pscheduler.timedelta_as_iso8601(delta)

   result['duration'] = duration

if options.interval is not None:

   interval = options.interval

   # convert epoch seconds to is8601
   if interval.isdigit():
      delta = datetime.timedelta(seconds=int(interval))
      interval = pscheduler.timedelta_as_iso8601(delta)

   result['interval'] = interval

if options.parallel is not None:
   result['parallel'] = options.parallel

if options.udp:
   result['udp'] = True

if options.bandwidth is not None:
   try:
      result['bandwidth'] = pscheduler.si_as_number(options.bandwidth)
   except ValueError as e:
      pscheduler.fail("Invalid value \"%s\" for bandwidth: %s" % (options.bandwidth, e))

if options.window_size is not None:
   try:
      result["window-size"] = pscheduler.si_as_number(options.window_size)
   except ValueError as e:
      pscheduler.fail("Invalid value \"%s\" for window size: %s" % (options.window_size, e))

if options.dynamic_window_size is not None:
   try:
      result["dynamic-window-size"] = pscheduler.si_as_number(options.dynamic_window_size)
   except ValueError as e:
      pscheduler.fail("Invalid value \"%s\" for dynamic window size: %s" % (options.dynamic_window_size, e))

if options.mss is not None:
   result["mss"] = options.mss

if options.buffer_length is not None:
   result["buffer-length"] = options.buffer_length

if options.force_ipv4:
   result["force-ipv4"] = True

if options.force_ipv6:
   result["force-ipv6"] = True

if options.local_address:
   result["local-address"] = options.local_address

if options.dscp:
   result["dscp"] = options.dscp

if options.omit:
   result["omit"] = options.omit

if options.tos:
   result["tos"] = options.tos

# This sort of belongs in spec-is-valid but has to be here because of 
# the below step where we assume "me" if one isn't specified
if not result.has_key("source") and not result.has_key("destination"):
   pscheduler.fail("Either or both of source or destination must be specified")

# Set default of either source or destination to "me" if not provided
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.connect(('8.8.8.8', 0))  # connecting to a UDP address doesn't send packets
me = s.getsockname()[0]

logger.debug("Me = %s" % me)

if not result.has_key("source") and result.has_key("destination"):
   result["source"] = me
elif not result.has_key("destination") and result.has_key("source"):
   result["destination"] = me

logger.debug("cli-to-spec -> %s" % result)

pscheduler.succeed_json(result)
