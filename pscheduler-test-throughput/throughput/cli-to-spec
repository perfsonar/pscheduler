#!/usr/bin/env python3
#
# Convert comamnd-line options to a test specification

import argparse
import pscheduler
import sys
import datetime

logger = pscheduler.Log(prefix='test-throughput', quiet=True)

if len(sys.argv) > 1:

   # Args are on the command line
   args = sys.argv[1:]

else:

   # Args are in a JSON array on stdin
   json_args = pscheduler.json_load(exit_on_error=True)
   args = []

   if not isinstance(json_args,list):
      pscheduler.fail("Invalid JSON for this operation")
   for arg in json_args:
      if not ( isinstance(arg, str)
               or isinstance(arg, int)
               or isinstance(arg, float) ):
         pscheduler.fail("Invalid JSON for this operation")
   args = [ str(arg) for arg in json_args ]



# Gargle the arguments

arg_parser = argparse.ArgumentParser(epilog=
"""Examples:

  task throughput --dest ps.example.com
      Measure througput from here to ps.example.com

  task throughput --source ps.example.org --dest ps.example.com
      Measure througput between ps.example.org and ps.example.com

  task throughput --bandwidth 384M --dest ps.example.com
      Limit bandwidth to 384 Mb per second

  task throughput --parallel 4 --dest ps.example.com
      Run four parallel streams
""",
    formatter_class=argparse.RawTextHelpFormatter)


arg_parser.add_argument("-s", "--source",
                      help="Sending host",
                      action="store", type=str,
                      dest="source")

arg_parser.add_argument("--source-node",
                      help="pScheduler node on sending host, if different",
                      action="store", type=str,
                      dest="source_node")

arg_parser.add_argument("-d", "--dest", "--destination",
                      help="Receiving host",
                      action="store", type=str,
                      dest="destination")

arg_parser.add_argument("--dest-node",
                      help="pScheduler node on receiving host, if different",
                      action="store", type=str,
                      dest="dest_node")

arg_parser.add_argument("-t", "--duration",
                      help="Total runtime of test",
                      action="store", type=str,
                      dest="duration")

arg_parser.add_argument("-i", "--interval",
                      help="How often to report results (internally, results still reported in aggregate at end)",
                      action="store", type=str,
                      dest="interval")

arg_parser.add_argument("--link-rtt",
                      help="Approximate link round-trip time (ISO8601 or integer ms)",
                      action="store", type=str,
                      dest="link_rtt")

arg_parser.add_argument("-P", "--parallel",
                      help="How many parallel streams to run during the test",
                      action="store", type=int,
                      dest="parallel")

arg_parser.add_argument("-u", "--udp",
                      help="Use UDP instead of TCP testing",
                      action="store_true", 
                      dest="udp")

arg_parser.add_argument("-b", "--bandwidth",
                      help="Bandwidth to rate limit the test to, supports SI notation such as 1G",
                      action="store", type=str,
                      dest="bandwidth")

arg_parser.add_argument("--bandwidth-strict",
                      help="Never go faster than --bandwidth, even to make up for lost time.",
                      default=None,
                      action="store_true",
                      dest="bandwidth_strict")

arg_parser.add_argument("--burst-size",
                      help="Limit bursts of packets to this number",
                      action="store", type=str,
                      dest="burst_size")

arg_parser.add_argument("--fq-rate",
                      help="Fair queueing rate, supports SI notation such as 1G",
                      action="store", type=str,
                      dest="fq_rate")

arg_parser.add_argument("-w", "--window-size",
                      help="TCP window (buffer) size to use for the test, supports SI notation such as 64M",
                      action="store", type=str,
                      dest="window_size")

arg_parser.add_argument("-m", "--mss",
                      help="TCP maximum segment size",
                      action="store", type=int,
                      dest="mss")

arg_parser.add_argument("-l", "--buffer-length",
                      help="length of the buffer to read/write from",
                      action="store", type=int,
                      dest="buffer_length")

arg_parser.add_argument("--ip-tos",
                      help="IP type-of-service octet (integer)",
                      action="store", type=int,
                      dest="ip_tos")

arg_parser.add_argument("--ip-version",
                      help="Specificy which IP version to use, 4 or 6",
                      action="store", type=int,
                      dest="ip_version")

arg_parser.add_argument("-B", "--local-address",
                      help="Use this as a local address for control and tests",
                      action="store", type=str,
                      dest="local_address")

arg_parser.add_argument("-O", "--omit",
                      help="Number of seconds to omit from the start of the test",
                      action="store", type=str,
                      dest="omit")

arg_parser.add_argument("--no-delay",
                      help="Set TCP no-delay flag, disables Nagle's algorithm",
                      action="store_true",
                      dest="no_delay")

arg_parser.add_argument("--congestion",
                      help="Set TCP congestion control algorithm",
                      action="store", type=str,
                      dest="congestion")

arg_parser.add_argument("--zero-copy",
                      help="Use a 'zero copy' method of sending data",
                      action="store_true",
                      dest="zero_copy")

arg_parser.add_argument("--flow-label",
                      help="Set the IPv6 flow label, implies --ip-version 6",
                      action="store", type=int,
                      dest="flow_label")

arg_parser.add_argument("--client-cpu-affinity",
                      help="Set's the sending side's CPU affinity",
                      action="store", type=int,
                      dest="client_cpu_affinity")

arg_parser.add_argument("--server-cpu-affinity",
                      help="Set's the receiving's side's CPU affinity",
                      action="store", type=int,
                      dest="server_cpu_affinity")

arg_parser.add_argument("--single-ended",
                      help="Run a test directly to a host without pscheduler.",
                      action="store_true",
                      dest="single_ended")

arg_parser.add_argument("--single-ended-port",
                      help="Run a test directly to a given port.",
                      action="store", type=int,
                      dest="single_ended_port")

arg_parser.add_argument("--reverse",
                      help="Reverses the direction of the test.",
                      action="store_true",
                      dest="reverse")

arg_parser.add_argument("--reverse-connections",
                      help="Make connections from destination to source where possible.",
                      action="store_true",
                      dest="reverse_connections")

arg_parser.add_argument("--loopback",
                      help="Run both client and server side in a loopback test.",
                      action="store_true",
                      dest="loopback")

args = arg_parser.parse_args(args)

result = { }
schema = pscheduler.HighInteger(1)

if args.source is not None:
   result['source'] = args.source

if args.source_node is not None:
   result['source-node'] = args.source_node
   
if args.destination is not None:
   result['dest'] = args.destination

if args.dest_node is not None:
   result['dest-node'] = args.dest_node

if args.duration is not None:
   duration = args.duration

   # convert epoch seconds to is8601
   if duration.isdigit():
      delta = datetime.timedelta(seconds=int(duration))
      duration = pscheduler.timedelta_as_iso8601(delta)

   result['duration'] = duration

if args.interval is not None:

   interval = args.interval

   # convert epoch seconds to is8601
   if interval.isdigit():
      delta = datetime.timedelta(seconds=int(interval))
      interval = pscheduler.timedelta_as_iso8601(delta)

   result['interval'] = interval

if args.link_rtt is not None:
   rtt_value = args.link_rtt
   try:
      result['link-rtt'] = "PT%sS" % (int(rtt_value) / 1000.0)
   except ValueError:
      result['link-rtt'] = rtt_value
   schema.set(3)


if args.parallel is not None:
   result['parallel'] = args.parallel

if args.udp:
   result['udp'] = True

if args.bandwidth is not None:
   try:
      result['bandwidth'] = pscheduler.si_as_number(args.bandwidth)
   except ValueError as ex:
      pscheduler.fail("Invalid value \"%s\" for bandwidth: %s" % (args.bandwidth, ex))

if args.bandwidth_strict is not None:
   result['bandwidth-strict'] = args.bandwidth_strict
   schema.set(4)

if args.burst_size is not None:
   try:
      result["burst-size"] = pscheduler.si_as_number(args.burst_size)
      schema.set(4)
   except ValueError as ex:
      pscheduler.fail("Invalid value \"%s\" for burst size: %s" % (args.window_size, ex))

if args.fq_rate is not None:
   try:
      result['fq-rate'] = pscheduler.si_as_number(args.fq_rate)
      schema.set(7)
   except ValueError as ex:
      pscheduler.fail("Invalid value \"%s\" for fq-rate: %s" % (args.fq_rate, ex))

if args.window_size is not None:
   try:
      result["window-size"] = pscheduler.si_as_number(args.window_size)
   except ValueError as ex:
      pscheduler.fail("Invalid value \"%s\" for window size: %s" % (args.window_size, ex))

if args.mss is not None:
   result["mss"] = pscheduler.si_as_number(args.mss)

if args.buffer_length is not None:
   result["buffer-length"] = pscheduler.si_as_number(args.buffer_length)

if args.ip_version is not None:
   result["ip-version"] = args.ip_version

if args.local_address:
   result["local-address"] = args.local_address

if args.omit:
   omit = args.omit

   # convert epoch seconds to is8601
   if omit.isdigit():
      delta = datetime.timedelta(seconds=int(omit))
      omit  = pscheduler.timedelta_as_iso8601(delta)

   result["omit"] = omit
   

if args.ip_tos:
   result["ip-tos"] = args.ip_tos

if args.no_delay:
   result["no-delay"] = True


if args.congestion:

   # In schemas 1-3, this value was a hard-coded list.  In schema 4,
   # it is no longer validated and is passed directly to the tool.  We
   # don't have to bump the schema for the old, hard-coded values.
   if args.congestion not in [ "bbr", "bic", "cubic", "htcp",
                                  "reno", "vegas", "westwood", "yeah" ]:
      schema.set(4)

   result["congestion"] = args.congestion

if args.zero_copy:
   result["zero-copy"] = True

if args.flow_label:
   result["flow-label"] = int(args.flow_label)
   result["ip-version"] = 6 # flow label only works on ipv6

if args.client_cpu_affinity != None:
   result["client-cpu-affinity"] = args.client_cpu_affinity

if args.server_cpu_affinity != None:
   result["server-cpu-affinity"] = args.server_cpu_affinity

if args.single_ended:
   result["single-ended"] = True
   schema.set(2)

if args.single_ended_port:
   result["single-ended-port"] = args.single_ended_port
   schema.set(2)

if args.reverse:
   result["reverse"] = True

if args.reverse_connections:
   result["reverse-connections"] = True
   schema.set(6)

if args.loopback:
   result["loopback"] = True
   schema.set(5)

result["schema"] = schema.value()

logger.debug("cli-to-spec -> %s" % result)

pscheduler.succeed_json(result)
