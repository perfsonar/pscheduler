#!/usr/bin/env python3
import select
from os import getpid, unlink, access, R_OK, listdir, path
from socket import socket, AF_UNIX, SOCK_DGRAM
import datetime
import pscheduler
import os

#temp file preserved between consecutive runs but not reboots
WPA_CONFIG_PATH = '/tmp/wpa_supplicant/wpa_supplicant.conf'
#initializes only when wpa_supplicant starts
WPA_CTRL_IFACE_BASE = '/var/run/wpa_supplicant'
interface = 'wlan0'
timeout = 3000
ssid_set = set()

# parse config
pscheduler_input = pscheduler.json_load(exit_on_error=True)
get_ssid = pscheduler_input['test']['spec'].get('ssid', None)
ssid_set = set(get_ssid.split(',')) if get_ssid else set()
duration_iso = pscheduler_input['test']['spec'].get('duration', 'PT5S')
timeout_iso = pscheduler_input['test']['spec'].get('timeout', 'PT10S')
timeout = pscheduler.timedelta_as_seconds(pscheduler.iso8601_as_timedelta(timeout_iso))
duration = pscheduler.timedelta_as_seconds(pscheduler.iso8601_as_timedelta(duration_iso)) 
start_time = datetime.datetime.now()
succeeded = False
error = ''
diags = ''
ssid_list = []

#check if interface already exists
if not access(f'{WPA_CTRL_IFACE_BASE}/{interface}', R_OK):
    #create config file and start wpa_supplicant
    with open(WPA_CONFIG_PATH, 'w') as f:
        f.write('ctrl_interface='+WPA_CTRL_IFACE_BASE+'\r\n')
        f.write('update_config=1\r\n')
    os.system('wpa_supplicant -B -i '+interface+' -c '+WPA_CONFIG_PATH)

#setting up socket
sock = socket(AF_UNIX, SOCK_DGRAM)
sock.settimeout(3)
start  = datetime.datetime.now()
# response will be written to this socket
recv_sock = f"/tmp/wpa_ctrl_{getpid()}"
sock.bind(recv_sock)

ctrl_interface = f"{WPA_CTRL_IFACE_BASE}/{interface}"

sock.connect(ctrl_interface)
print('start attaching at', datetime.datetime.now() - start)
# attach to wpa_supplicant
sock.send(b'ATTACH')

if sock.recv(3) != b'OK\n':
    raise OSError(f"error attaching to {ctrl_interface}")

# start scan
sock.send(bytes("SCAN", 'utf-8'))
# polling for scan results
poll = select.poll()
poll.register(sock, select.POLLIN)

data = []
# wait for scan to complete
while poll.poll(timeout):
    result = sock.recv(4096)
    if result.endswith(b'<3>CTRL-EVENT-SCAN-RESULTS '):
        sock.send(bytes("SCAN_RESULTS", 'utf-8'))
        break

# gather scan results
while poll.poll(200):
    result = sock.recv(8192)
    if result:
        data.append(result)

blob = data[1].decode('utf-8')
result = [s.split('\t') for s in blob.split('\n')][1:-1]

for bssid, freq, signal, flags, ssid in result:
    if not ssid_set or ssid in ssid_set:
        ssid_list.append({
            'ssid': ssid,
            'bssid': bssid,
            'freq': int(freq),
            'signal': int(signal),
            'flags': flags
        })
end_time = datetime.datetime.now()

# Organize results into json data
results = {
    'succeeded': succeeded,
    'result': {
        'schema': 1,
        'time': pscheduler.timedelta_as_iso8601(end_time - start_time),
        'succeeded': succeeded,
        'ssid_list': ssid_list
    },
    'error': error,
    'diags': diags 
}

# pscheduler.succeed_json(results)    
print(results)
print('finished at', datetime.datetime.now() - start)
