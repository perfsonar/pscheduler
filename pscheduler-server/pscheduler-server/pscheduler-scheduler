#!/usr/bin/python
#
# pScheduler Run Scheduler
#

import errno
import optparse
import pscheduler
import psycopg2
import psycopg2.extensions
import select
import socket
import sys
import time
import traceback

# Gargle the arguments

opt_parser = optparse.OptionParser()
opt_parser.add_option("-c", "--channel",
                      help="Schedule notification channel",
                      action="store", type="string", dest="channel",
                      default="task_change")
# TODO: Do we want pscheduler as the default here?
opt_parser.add_option("-d", "--dsn",
                      help="Database connection string",
                      action="store", type="string", dest="dsn",
                      default="dbname=pscheduler")
opt_parser.add_option("-r", "--refresh",
                      help="Forced refresh interval (ISO8601)",
                      action="store", type="string", dest="refresh",
                      default="PT15S")
opt_parser.add_option("-v", "--verbose", action="store_true", dest="verbose")
opt_parser.add_option("--debug", action="store_true", dest="debug")

(options, args) = opt_parser.parse_args()

refresh = pscheduler.iso8601_as_timedelta(options.refresh)
if refresh is None:
    opt_parser.error('Invalid refresh interval "' + options.refresh + '"')
if pscheduler.timedelta_as_seconds(refresh) == 0:
    opt_parser.error("Refresh interval must be calculable as seconds.")

log = pscheduler.Log(verbose=options.verbose, debug=options.debug)

dsn = options.dsn

# Minimum amount of time from now when the first run of a task can be
# scheduled.  This prevents "start now" tasks from being scheduled for
# a time before the participants can prepare for them.
# TODO: Potential race condition?
first_run_offset = pscheduler.iso8601_as_timedelta('PT10S')


#
# Main Program
#

def main_program():

    # TODO: All DB transactions need to be error checked

    pg = pscheduler.pg_connection(dsn)
    cursor = pg.cursor()
    cursor.execute("LISTEN " + options.channel)

    while True:

        # Wait for something to happen.

        log.debug("Waiting %s for notification", refresh)

        try:
            if select.select([pg],[],[],
                             pscheduler.timedelta_as_seconds(refresh)) != ([],[],[]):
                # Notified
                pg.poll()
                del pg.notifies[:]
                log.debug("Notified.")

        except select.error as ex:
            err_no, message = ex
            if err_no != errno.EINTR:
                log.exception()
                raise ex


        failed = False

        while not failed:

            cursor.execute("""SELECT uuid, runs, trynext from schedule_runs_to_schedule""")

            if cursor.rowcount == 0:
                log.debug("No runs to schedule.")
                break

            for row in cursor.fetchall():

                uuid, runs, trynext = row

                url = pscheduler.api_url(path='/tasks/' + uuid)

                # For the first run only, push the start time out.
                # See comment above near the declaration of
                # first_run_offset.

                if runs == 0:
                    later_start = pscheduler.time_now() + first_run_offset
                    if trynext < later_start:
                        trynext = later_start                   

                log.debug("Trying to schedule %s for %s at %s",
                          uuid, trynext, url)
                log.debug("URL is %s", url)
                run_uri, start_time, end_time, error = \
                    pscheduler.run_post(url, trynext, log)
                if error is not None:
                    log.debug("Unable: %s", error)
                    failed = True
                else:
                    log.debug("Scheduled for %s - %s at %s",
                              start_time, end_time, run_uri)


pscheduler.safe_run(lambda: main_program())
