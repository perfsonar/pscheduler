#!/usr/bin/env python3
#
# Convert comamnd-line options to a test specification

import argparse
import pscheduler
import sys

if len(sys.argv) > 1:

   # Args are on the command line
   args = sys.argv[1:]

else:

   # Args are in a JSON array on stdin
   json_args = pscheduler.json_load(exit_on_error=True)
   args = []

   if not isinstance(json_args,list):
      pscheduler.fail("Invalid JSON for this operation")
   for arg in json_args:
      if not ( isinstance(arg, str)
               or isinstance(arg, int)
               or isinstance(arg, float) ):
         pscheduler.fail("Invalid JSON for this operation")
   args = [ str(arg) for arg in json_args ]



# Gargle the arguments

arg_parser = argparse.ArgumentParser(epilog=
"""Examples:

  task latency --dest ps.example.com
      Measure latency from here to ps.example.com

  task latency --source ps2.example.org --dest ps.example.com
      Measure latency from ps2.example.org to ps.example.com

  task latency --packet-count 38 --dest ps.example.com
      Send 38 packets

  task latency --ip-version 6 --dest ps.example.com
      Use IPv6
""",
    formatter_class=argparse.RawTextHelpFormatter)


arg_parser.add_argument("-s", "--source",
                      help="The address of the entity sending packets in this test",
                      action="store", type=str,
                      dest="source")

arg_parser.add_argument("--source-node",
                      help="The address of the source pScheduler node, if different",
                      action="store", type=str,
                      dest="source_node")

arg_parser.add_argument("-d", "--dest",
                      help="The address of the entity receiving packets in this test",
                      action="store", type=str,
                      dest="dest")

arg_parser.add_argument("--dest-node",
                      help="The address of the destination pScheduler node, if different",
                      action="store", type=str,
                      dest="dest_node")

arg_parser.add_argument("--protocol",
                      help="The protocol to use in making the measurement",
                      action="store", type="str",
                      dest="protocol")

arg_parser.add_argument("-c", "--packet-count",
                      help="The number of packets to send",
                      action="store", type=int,
                      dest="packet_count")

arg_parser.add_argument("-i", "--packet-interval",
                      help="The number of seconds to delay between sending packets",
                      action="store", type=float,
                      dest="packet_interval")

arg_parser.add_argument("-L", "--packet-timeout",
                      help="The number of seconds to wait before declaring a packet lost",
                      action="store", type=float,
                      dest="packet_timeout")

arg_parser.add_argument("-p", "--packet-padding",
                      help="The size of padding to add to the packet in bytes",
                      action="store", type=int,
                      dest="packet_padding")

arg_parser.add_argument("-C", "--ctrl-port",
                      help="The port to use for making a control connection to the side acting as a server.",
                      action="store", type=int,
                      dest="ctrl_port")

arg_parser.add_argument("-P", "--data-ports",
                      help="The port range to use on the side of the test running the client. At least two ports required.",
                      action="store", type=str,
                      dest="data_ports")

arg_parser.add_argument("-T", "--ip-tos",
                      help="The IP type-of-service value.",
                      action="store", type=int,
                      dest="ip_tos")

arg_parser.add_argument("--ip-version",
                      help="Force an IP version when performing the test. Useful when specifying hostnames as source or dest that may map to both IPv4 and IPv6 addresses.",
                      action="store", type=int, dest="ip_version")

arg_parser.add_argument("-b", "--bucket-width",
                      help="The bin size to use for histogram calculations. This value is divided into the result as reported in seconds and truncated to the nearest 2 decimal places.",
                      action="store", type=float,
                      dest="bucket_width")

arg_parser.add_argument("-f", "--flip",
                      help="In multi-participant mode, have the dest start the client and request a reverse test. Useful in some firewall and NAT environments.",
                      action="store_true", dest="flip", default=False)

arg_parser.add_argument("-r", "--reverse",
                      help="Report results in the reverse direction (destination to source) if possible.",
                      action="store_true", dest="reverse", default=None)

arg_parser.add_argument("--traverse-nat",
                      help="Take steps to traverse outbound NAT",
                      action="store_true", dest="traverse_nat", default=False)

arg_parser.add_argument("-R", "--output-raw",
                      help="Output individual packet statistics. This will substantially increase the size of a successful result.",
                      action="store_true", dest="output_raw", default=None)

args = arg_parser.parse_args(args)


spec_schema = pscheduler.HighInteger(1)

result = {}

if args.source is not None:
   result['source'] = args.source

if args.source_node is not None:
   result['source-node'] = args.source_node

if args.dest is not None:
   result['dest'] = args.dest

if args.dest_node is not None:
   result['dest-node'] = args.dest_node

if args.packet_count is not None:
   result['packet-count'] = args.packet_count

if args.protocol is not None:
   result['protocol'] = args.protocol
   spec_schema.set(4)

if args.packet_interval is not None:
   result['packet-interval'] = args.packet_interval

if args.packet_timeout is not None:
   result['packet-timeout'] = args.packet_timeout

if args.packet_padding is not None:
   result['packet-padding'] = args.packet_padding

if args.ctrl_port is not None:
    result['ctrl-port'] = args.ctrl_port

if args.data_ports is not None:
   ports = args.data_ports.strip().split("-");
   if len(ports) != 2:
        pscheduler.fail("Invalid data-ports. Must be in the form of LOWER-UPPER")
   if ports[0] > ports[1]:
        pscheduler.fail("Invalid data-ports. First value in range must be less than second")
   if ports[0] == ports[1]:
        pscheduler.fail("Invalid data-ports.First value and second value cannot be equal. Must specify at least two ports.")
   result['data-ports'] = {
        "lower": int(ports[0]),
        "upper": int(ports[1])
   }

if args.ip_tos is not None:
   result['ip-tos'] = args.ip_tos

if args.ip_version is not None:
   result['ip-version'] = args.ip_version

if args.bucket_width is not None:
   result['bucket-width'] = args.bucket_width

if args.flip:
   result['flip'] = args.flip

if args.reverse:
   result['reverse'] = args.reverse
   spec_schema.set(2)

if args.traverse_nat:
   result['traverse-nat'] = args.traverse_nat
   spec_schema.set(3)

if args.output_raw:
   result['output-raw'] = args.output_raw


result['schema'] = spec_schema.value()


pscheduler.succeed_json(result)
