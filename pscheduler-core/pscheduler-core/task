#!/usr/bin/python
#
# Command-Line Interface for running tasks
#

# General syntax:
#     pscheduler task [options] [schedule-opts] test-type [test-opts]

# TODO: Get rid of the print statements in favor of some narrator
# class we can shut off if the options call for quiet.

import datetime
import optparse
import os
import pscheduler
import subprocess
import sys
import time

#
# Gargle the arguments
#

usage = "Usage: %prog [options] test-type [test-options]"
opt_parser = optparse.OptionParser(usage = usage)
opt_parser.disable_interspersed_args()

# GENERAL OPTIONS

opt_parser.add_option("--assist", "-a",
                      help="Use the named host for assistance (default localhost or $PSCHEDULER_ASSIST)",
                      action="store", type="string",
                      dest="assist")  # Conflict with reserved word

opt_parser.add_option("--export", '-e',
                      help="Export task JSON to stdout and exit",
                      action="store_true", default=False,
                      dest="export")

opt_parser.add_option("--format", "-f",
                      help="Output format: plain (default), html, json or none",
                      action="store", type="string",
                      default="text",
                      dest="format")

opt_parser.add_option("--import", "-i",
                      help="Read JSON task template from a file, - for stdin",
                      action="store", type="string",
                      dest="importt")  # Conflict with reserved word

opt_parser.add_option("--quiet", '-q',
                      help="Operate quietly",
                      action="store_true", default=False,
                      dest="quiet")
opt_parser.add_option("--no-quiet",
                      help="Don't operate quietly",
                      action="store_false",
                      dest="quiet")


opt_parser.add_option("--url",
                      help="Dump a URL that points to the task after posting and exit",
                      action="store_true", default=False,
                      dest="url")

opt_parser.add_option("--wait",
                      help="Wait for n runs of test",
                      action="store", type="int", default=1,
                      dest="wait")

# SCHEDULING OPTIONS

opt_parser.add_option("--max-runs",
                      help="Maximum number of repeats",
                      action="store", type="int", default=1,
                      dest="max_runs")

# TODO: Find a way to get rid of the rounding error in this.
opt_parser.add_option("--randslip",
                      help="Random slip fractiom (float in [0.0..1.0])",
                      action="store", type="float",
                      dest="randslip")

opt_parser.add_option("--repeat",
                      help="Repeat interval (ISO 8601 Duration)",
                      action="store", type="string",
                      dest="repeat")

opt_parser.add_option("--slip",
                      help="Allowed start slip (ISO8601 Duration)",
                      action="store", type="string",
                      dest="slip")

opt_parser.add_option("--start",
                      help="Start time",
                      action="store", type="string",
                      dest="start")

opt_parser.add_option("--until",
                      help="Time after which scheduling should stop",
                      action="store", type="string",
                      dest="until")


# TODO:  Need a --tool option to force a list of preferred tools.

(options, remaining_args) = opt_parser.parse_args()

if len(remaining_args) < 1:
    opt_parser.print_usage()
    pscheduler.fail()

#
# Validate the command line
#

if options.max_runs < 1:
    pscheduler.fail("Invalid --max-runs; must be 1 or more")


formats = {
    'html': 'text/html',
    'json': 'application/json',
    'none': None,
    'text': 'text/plain',
    # Not "officially" supported, but here for completeness
    'text/html': 'text/html',
    'text/json': 'application/json',
    'text/plain': 'text/plain',
    }

try:
    format = formats[options.format]
except KeyError:
    pscheduler.fail("Invalid --format; must be text, html, json or none")


if options.repeat is not None:
    repeat = pscheduler.iso8601_as_timedelta(options.repeat)
    if repeat is None:
        pscheduler.fail("Invalid --repeat; must be ISO 8601 duration")


if options.randslip is not None:
    randslip = options.randslip
    if randslip < 0.0 or randslip > 1.0:
        pscheduler.fail("Invalid --randslip; must be in [0.0..1.0]")

if options.slip is not None:
    slip = pscheduler.iso8601_as_timedelta(options.slip)
    if slip is None:
        pscheduler.fail("Invalid --slip; must be ISO 8601 duration")
elif options.repeat is None:
    # TODO: This is a stopgap that forces slip on non-repeating tasks
    # so scheduling won't fail if there isn't an immediate slot
    # available on the schedule.  See issue #30.
    slip = datetime.timedelta(minutes=10)
    

if options.start is not None:
    # TODO: Support "Pxx" and "@Pxx" formats like the database does
    # Should have a module function that does this.
    start = pscheduler.iso8601_as_datetime(options.start, localize=True)
    if start is None:
        pscheduler.fail("Invalid --start")
    if start <= pscheduler.time_now():
        pscheduler.fail("Invalid --start; must be in the future.")
    pass

if options.until is not None:
    # TODO: Support "Pxx" and "@Pxx" formats like the database does
    # TODO: Error handling in iso8601_as_datetime() needs improvement.
    until = pscheduler.iso8601_as_datetime(options.until, localize=True)
    if until is None:
        pscheduler.fail("Invalid --until")
    if until <= pscheduler.time_now():
        pscheduler.fail("Invalid --until; must be in the future.")

if options.wait < 0:
    pscheduler.fail("Invalid --wait; must be 0 or more")

if ( options.repeat is None
     and (
        (options.max_runs is not None and options.max_runs > 1)
        or options.until is not None
        )
     ):
         pscheduler.fail("Using --repeat is required with other"
                         " repetition-related options.")


verbose = not options.quiet


# Decide who assists us.

assist = options.assist
if assist is None:
    assist = os.getenv('PSCHEDULER_ASSIST')

# Last-ditch default
if assist is None:
    assist = '127.0.0.1'
else:
    if verbose:
        print "Assistance will be from", assist
    pass


#
# If we were asked to read in some JSON, do that.  Anything the
# options add will override it.
#

if options.importt is None:
    task = {
        'schema': 1,
        'schedule': {},
        'test': {
            'spec': {}
            }
        }
    task_read = False
else:
    if options.importt == '-':
        file = sys.stdin
    else:
        try:
            file = open(options.importt)
        except IOError as ex:
            pscheduler.fail("Unable to open task %s" % (str(ex)))
    task = pscheduler.json_load(file, exit_on_error=True)
    # TODO: Validate what we read as a task.
    task_read = True

#
# Overlay schedule options
#

# TODO: Remove after validation
assert 'schedule' in task

if options.max_runs > 1:
    task['schedule']['max-runs'] = options.max_runs

if options.repeat is not None:
    task['schedule']['repeat'] = options.repeat

if options.randslip is not None:
    task['schedule']['randslip'] = options.randslip

if options.slip is not None:
    task['schedule']['slip'] = options.slip

if options.start is not None:
    task['schedule']['start'] = options.start

if options.until is not None:
    task['schedule']['until'] = options.until


#
# Figure out what kind of test this is.  Don't worry about it being
# valid, that will be checked later.
#

if task_read:
    try:
        test_type = task['test']['type']
        remaining_args.pop(0)
    except KeyError:
        pscheduler.fail("Template has no type defined.")
    except IndexError:
        pscheduler.fail("No placeholder task type specified.",
                        "  (Should be '-'.)")
else:
    try:
        test_type = remaining_args.pop(0)
    except IndexError:
        pscheduler.fail("No test type specified.")

assert test_type is not None

task['test']['type'] = test_type

#
# Convert the remaining arguments to a test spec.
#

status, raw_spec = pscheduler.url_get(
    pscheduler.api_url(host=assist,
                       path='/tests/' + test_type + '/spec'),
    params={ 'args': pscheduler.json_dump(remaining_args) },
    throw=False
    )

if status == 404:
    pscheduler.fail("Could not find test " + test_type + " on server")
elif status != 200:
        pscheduler.fail(raw_spec)

json_to_merge = raw_spec
assert 'spec' in task['test']
task['test']['spec'].update(json_to_merge)

task_json_text = pscheduler.json_dump(task)


if options.export:
    pscheduler.json_dump(obj=task, dest=sys.stdout, pretty=True)
    print
    pscheduler.succeed()


#
# Contact the assist server
#

status, text =  pscheduler.url_get( pscheduler.api_url(assist, '/hostname'),
                                    throw=False )
if status != 200:
    pscheduler.fail("Can't talk to the pScheduler server at %s: %s"
                    % (assist, text))



# TODO: Validate the test before figuring out who's involved.

#
# Determine the lead participant
#

url = pscheduler.api_url(assist, '/tests/%s/lead' % task['test']['type'])

try:
    status, lead = pscheduler.url_get( url, params={
            'spec': pscheduler.json_dump(task['test']['spec'])
            } )
except Exception as ex:
    pscheduler.fail("Unable to determine the lead participant: " + str(ex))


#
# Give the task to the lead for scheduling.
#

try:
    status, task_url = pscheduler.url_post( pscheduler.api_url(lead, '/tasks'),
                                            data=task_json_text,
                                            throw=False)
except Exception as ex:
    pscheduler.fail("Unable to post task: " + str(ex))

if status != 200:
    pscheduler.fail("Unable to post task: " + task_url)

# If asked to just dump the URL, do that and exit.
if options.url:
    pscheduler.succeed(task_url)

if verbose:
    print "Task URL:"
    print task_url


# TODO: Everything below this is fundamentally what's in the 'watch'
# program.  Should probably just run that instead.

#
# Get the first future run.
#

if verbose:
    print "Fetching first run..."

# TODO: It would be more RESTful to have this URL available as part of
# the task instead of building it here.

runs_url = task_url + '/runs/first'
status, run_json = pscheduler.url_get(runs_url,
                                      params= { 'wait-local': True },
                                      throw=False)

# TODO: Need to display something meaningful when this happens.  We
# should have a way to put stillborn runs in the database with
# diagnostics.

if status == 404:
    pscheduler.fail("Run on server was never populated.")

if status != 200:
    pscheduler.fail("Failed to fetch run: " + run_json)

run_url = run_json['href']

if verbose:
    print "Run URL:"
    print run_url


#
# Wait for the run to start and finish and fetch the results
#

start_time = run_json['start-time']
wait_time = pscheduler.time_until_seconds(
    pscheduler.iso8601_as_datetime(start_time))
if verbose:
    print "Run start: %s (~%s seconds)" % (start_time, int(wait_time))
time.sleep(wait_time)

end_time = run_json['end-time']
wait_time = pscheduler.time_until_seconds(
    pscheduler.iso8601_as_datetime(end_time))
if verbose:
    print "Run end:   %s (~%s seconds)" % (end_time, int(wait_time))
time.sleep(wait_time)

if verbose:
    print "Waiting for results..."

status, result = pscheduler.url_get( run_url,
                                      params={ 'wait-merged': True },
                                     throw=False )

if status != 200:
    pscheduler.fail("Failed to fetch run: %d: %s" % (status, result))

#
# If failed, dump diags.
#

# TODO: Need to do a better job picking this apart.  The full-result
# member needs to be populated whether the test succeeded or not.

try:
    if (not 'result-merged' in result) \
            or (result['result-merged'] is None):
        raise KeyError()
    status = result['result-merged']['succeeded']
except KeyError as ex:
    print "Unable to determine success or failure.  Returned JSON:"
    print pscheduler.json_dump(result, pretty=True)
    pscheduler.fail()


if not status:
    # TODO: Should have something nicer that dumps out the
    # participants and what they said.
    print
    print "Run failed.  The following errors were reported:"

    participants = result['participants']
    full = result['result-full']

    for participant in range(0, len(result['participants'])):
        print "%s:" % participants[participant]
        try:
            print '   ',
            full_part = full[participant]
            if full_part is not None:
                print '\n    '.join(full[participant]['error'].split('\n'))
            else:
                print '(No error reported)'
        except KeyError:
            # TODO: There should be an 'error' in the JSON, but don't
            # punish the user if there isn't.
            print "  (No error reported)"
    pscheduler.fail()


#
# Print the final result.
#

# Easy out.
if format is None:
    pscheduler.succeed()

status, formatted = pscheduler.url_get(
    result['result-href'],
    params={ 'wait': True,
             'format': format },
    json=False,
    throw=False)

if status != 200:
    pscheduler.fail("Unable to retrieve formatted result: " + formatted)

if verbose:
    print
print formatted.rstrip()
pscheduler.succeed()
