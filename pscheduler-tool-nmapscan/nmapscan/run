#!/usr/bin/env python3
#
# Development Order #5:
#
# This is the meat and bones of the tool, where the actual desired
# commands or operation will be run. The results are then recorded
# and added to the 'results' JSON data, which will then be sent
# back to the test. Both system and api are able to be used here.
#

import subprocess
import json
import sys
import nmap3
import pscheduler


# from stdin
input = pscheduler.json_load(exit_on_error=True)

spec = input['test']['spec']
timeout_iso = spec.get('timeout', 'PT10S')
timeout = pscheduler.timedelta_as_seconds( pscheduler.iso8601_as_timedelta(timeout_iso) )
succeeded = False
error = ''
diags = ''

host = spec["network"]
ports = spec.get("ports")
source = spec.get("source")
###################################################
version_detect = spec.get("versionDetect")
###################################################
def valid_ipv4(hostString):
    a = hostString.split('.')
    if len(a) != 4:
        return False
    for group in a:
        if (group.find("/")!=-1):
            group = group[:group.find("/")]
        if not group.isdigit():
            return False
        i = int(group)
        if i < 0 or i > 255:
            return False
    return True

def valid_ipv6(hostString):
    #account for omitted 0's
    o = hostString.find("::")
    if (o != -1):
        hostString.count(":")
        hostString = hostString[:o]+":"*(7-hostString.count(":"))+hostString[o:]

    a = hostString.split(':')
    if len(a) != 8:
        return False
        
    for group in a:
        if (group == ''): group = '0000'
        if (group.find("/")!=-1):
            group = group[:group.find("/")]
        try:
            decimal = int(group, 16)
        except ValueError:
            return False
        if decimal < 0 or decimal > 65535:
            return False
    return True

#-------------------------------------------------------------------------------Nmap Class
class NmapObj:
    def __init__(self, host, ports):
        self.args = ""
        self.hosts = list()
        self.hosts.append(host)
        self.raw = ""
        self.result = dict()
        if (valid_ipv6(host)): 
            self.args+="-6"
        self.version = False
        self.os = False
        self.versionInfo = dict()

    def enable_version_detect(self):
        self.args += " -sV"
        self.version = True

    def add_ports(self, ports):
        ports = ports.strip(" ")
        self.args+=" -p " + ports

    def set_source(self, source):
        self.args+=" -S "+source

    def set_timeout(self, timeout):
        self.args+=" --host-timeout " + str(timeout)


    def scan(self):
        nmapScanner = nmap3.Nmap()
        try:
            results = nmapScanner.scan_top_ports(self.hosts[0], default=1000, args=self.args)
        except Exception as e:
            if "Could not figure out what device to send the packet out on with the source address you gave me!" in str(e):
                print("Source address must be a valid local host address.", file=sys.stderr)
            else:
                print("Unknown nmap error. Check input parameters.", file=sys.stderr)
        self.raw = results
        self.hosts = list(results.keys())[:-2]
        self.result = dict()
        for host in self.hosts:
            for port in results[host]["ports"]:
                if(not self.version):
                    try:
                        self.result[host][port["portid"]] = port["state"]
                    except KeyError:
                        self.result[host] = dict()
                        self.result[host][port["portid"]] = port["state"]
                else:
                    try:
                        if("service" in port):
                            self.result[host][port["portid"]] = port["service"]
                        else: self.result[host][port["portid"]] = dict()
                        self.result[host][port["portid"]]["state"] = port["state"]
                    except KeyError:
                        self.result[host] = dict(dict())
                        if("service" in port):
                            self.result[host][port["portid"]] = port["service"]
                        else: self.result[host][port["portid"]] = dict()
                        self.result[host][port["portid"]]["state"] = port["state"]
        output = self.result

        return output
#-------------------------------------------------------------------------------Nmap Class

# IMPORTANT NOTE: This code puts the process to sleep until the
# scheduled start time has arrived.  It should be placed after all
# preparatory code has been executed and immediately before the tool # is invoked (for plugins that run other programs) or any activity
# that does a measurement (for those that don't).  
try:
    pscheduler.sleep_until(input['schedule']['start'])
except KeyError:
    pscheduler.fail("Unable to find start time in input")

#TODO: check for errors
nmap = NmapObj(host, ports)

if (ports is not None and ports != ""): nmap.add_ports(ports)
if (source is not None and source != ""): nmap.set_source(source)
#if ((valid_ipv4(host) and valid_ipv6(source)) or (valid_ipv6(host) and not valid_ipv6(source))):
#    print("Host and Source Address must use same IP version formats", file = sys.stderr)
#    exit(1)

if (timeout is not None and timeout != ""): nmap.set_timeout(timeout)
if (version_detect): nmap.enable_version_detect()
output = nmap.scan()
if output is not None: succeeded = True



# Organize results into json data
results = {
    'succeeded': succeeded,
    'result': {
         'succeeded' : succeeded,
         'result' : output,
         'error'  : error,
         'diags'  : diags
    },
    'error': error,
    'diags': diags }

pscheduler.succeed_json(results)
