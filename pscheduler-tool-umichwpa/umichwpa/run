#!/usr/bin/env python3

#
# Development Order #5:
#
# This is the meat and bones of the tool, where the actual desired
# commands or operation will be run. The results are then recorded
# and added to the 'results' JSON data, which will then be sent
# back to the test. Both system and api are able to be used here.
#

import datetime
import subprocess
import json
import sys
import time
import os
import pscheduler
import tempfile

# error and diagnostic tracking
error = ''
diags = ''
authenticated = False
need_root = False

# declare local variables
interface = ''
path = ''
username = ''
password = ''
driver = ''
ssid = ''
bssid = ''
key_managment = ''
timeout = 4000

# from stdin
input = pscheduler.json_load(exit_on_error=True)

# take input from test spec
interface = input['test']['spec']['interface']

try:
    username = input['test']['spec']['_username']
except KeyError:
    diags += "Proceeding without a username"

try:
    password = input['test']['spec']['_password']
except KeyError:
    diags += "Proceeding without a password"

ssid = input['test']['spec']['ssid']

try:
    bssid = input['test']['spec']['bssid']
except KeyError:
    diags += "Proceeding without a bssid"

key_management = input['test']['spec']['key-management']
diags += "Proceeding without key_management"

try:
    token = input['test']['spec']['token']
    with open('/etc/tokens', 'r') as f:
        for line in f:
            identifier, usrname, pwd = line.split(' ')
            if identifier == token:
                username = usrname
                password = pwd
except KeyError:
    diags += "proceeding without token"

# validate the existance of username and password
if not username and not password:
     pscheduler.succeed_json( {
        'succeeded': False,
        'diags': '',
        'error': ' username or/and password not supplied ',
        'result': None
        })

timeout_iso = input['test']['spec'].get('timeout', 'PT10S')
timeout = pscheduler.timedelta_as_seconds( pscheduler.iso8601_as_timedelta(timeout_iso) )
succeeded = False

WPA_CONFIG_PATH = '/tmp/wpa_supplicant.conf'
WPA_CTRL_IFACE_BASE = '/var/run/wpa_supplicant'

# use wpa_cli to check if the interface exists
wpa_status = ["sudo", "wpa_cli", "status"]
status, stdout, stderr = pscheduler.run_program(wpa_status, timeout=timeout)
if status:
    with open(WPA_CONFIG_PATH, 'w') as f:
        f.write('update_config=1\r\n')
        f.write('p2p_disabled=1\r\n')
    status, out, err = pscheduler.run_program(['sudo','wpa_supplicant','-Dnl80211','-B','-i',interface,'-c',WPA_CONFIG_PATH])
    if status:
         pscheduler.succeed_json( {
            'succeeded': False,
            'diags': '' + out,
            'error': 'failed to initialize interface: ' + err,
            'result': None
            })
    else:
        diags += out

# write the config file for reconfiguring the interface
temp = open(WPA_CONFIG_PATH,'w')
temp.writelines(['ctrl_interface=DIR=/var/run/wpa_supplicant\n', 'update_config=1\n', 'country=US\n', 'p2p_disabled=1\n',  'network={\n'])
temp.write('ssid="{}"\n'.format(ssid))
temp.write('scan_ssid=1\n')
if bssid != '':
    temp.write('bssid={}\n'.format(bssid))
temp.write('key_mgmt={}\n'.format(key_management))
temp.write('identity="{}"\n'.format(username))
temp.write('password="{}"\n'.format(password))
temp.write('eap=PEAP\n')
temp.write('phase1="peaplabel=0"\n')
temp.write('phase2="auth=MSCHAPV2"\n')
temp.write('}\n')
temp.close()

# reconfigure the interface and establish connection
start_time = datetime.datetime.now()
wpa_auth = ['sudo', 'wpa_cli', '-i', interface, 'reconfigure']
status, stdout, stderr = pscheduler.run_program(wpa_auth, timeout=timeout)
if status != 0:
    error += 'Error returned: \n%s' % stderr.strip('\n')
    succeeded = False
    fail_json = { 'succeeded': succeeded,
              'error': 'failed to reconfigure interface',
              'diags': diags }
else:
    diags += stdout
    succeeded = True

wpa_status = ["sudo", "wpa_cli", "status"]
status, stdout, stderr = pscheduler.run_program(wpa_status, timeout=timeout)
if status != 0:
    error += 'Error returned: \n%s' % stderr.strip('\n')
    succeeded = False
    fail_json = { 'succeeded': succeeded,
              'error': 'failed to run wpa_cli to validate the authentication',
              'diags': diags }
else:
    diags += stdout
    succeeded = True

# iteratively checks the wpa state until completion
res = stdout.split('\n')
while "wpa_state=COMPLETED" not in res:
    status, stdout, stderr = pscheduler.run_program(wpa_status, timeout=timeout)
    res = stdout.split('\n')
    time.sleep(0.3)

# get the end time for wpa_supplicant to be initialized
end_time = datetime.datetime.now()

# organize results into json data
results = {
    'succeeded': succeeded,
    'result': {
        'schema': 1,
        'time': pscheduler.timedelta_as_iso8601( end_time - start_time),
        'succeeded': succeeded,
        'final': res
    },
    'error': error,
    'diags': diags }

pscheduler.succeed_json(results)
